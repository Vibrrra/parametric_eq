

import { EQGraphManager, EQDesign } from "eq_canvas.slint";
import { HorizontalBox } from "std-widgets.slint";
export enum EQFilterTypeEnum {
        lowpass,
        highpass,
        bandpass,
        lowshelf,
        highshelf,
        notch,
        peaking,
}

export enum FilterControlType{
    frequency,
    gain,
    q,
    enabled,
    selected,
}

export struct EQFilterType {
    str: string,
    type: EQFilterTypeEnum,
}

export struct EqFilter {
    filter_type: EQFilterType,
    frequency: float,
    huge_frequency: bool,
    parsed_frequency: float,
    gain: float,
    q: float,
    enabled: bool,
    selected: bool,
    curve: string,
    circle_x: length,
    circle_y: length,
}

export global EQManagerSettings {

    in-out property <float> sample_rate: 48000.0; 
    in-out property <int> num_freq_points: 250;
    in-out property <float> skew_factor: 0.3;
    in-out property <float> max_gain: 30.0;
    in-out property <float> max_freq: 20000.0;
    in-out property <float> min_freq: 20.0;
    in-out property <float> min_q: 0.1;
    in-out property <float> max_q: 10.0;
    in-out property <length> eq_graph_height: 400px;
    in-out property <length> eq_graph_width: 800px;

    in-out property <[EqFilter]> eq_filters:
        [{filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 50.0,   gain: 0.0, q: 1.0, enabled: true,  selected: false, curve: "M 0 0 L 400 200 L 800 0"}, 
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 100.0,  gain: 0.0, q: 1.0, enabled: false, selected: false},
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 200.0,  gain: 0.0, q: 1.0, enabled: false, selected: false},
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 500.0,  gain: 0.0, q: 1.0, enabled: false, selected: false},
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 1000.0, gain: 0.0, q: 1.0, enabled: false, selected: false},
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 2000.0, gain: 0.0, q: 1.0, enabled: false, selected: false},
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 4000.0, gain: 0.0, q: 1.0, enabled: false, selected: false},
         {filter_type: EQManagerSettings.list-of-filter-types[5], frequency: 8000.0, gain: 0.0, q: 1.0, enabled: false, selected: false},
    ]; 

    out property<[{str: string, type: EQFilterTypeEnum}]> list-of-filter-types: 
        [{str: "LowPass"  , type: EQFilterTypeEnum.lowpass,  }, 
         {str: "HighPass" , type: EQFilterTypeEnum.highpass, },
         {str: "BandPass" , type: EQFilterTypeEnum.bandpass, },
         {str: "PeakingEQ", type: EQFilterTypeEnum.peaking,}, 
         {str: "LowShelf" , type: EQFilterTypeEnum.lowshelf, },
         {str: "HighShelf", type: EQFilterTypeEnum.highshelf,}
    ];
}


export global EQManagerUI {

    in-out property <[EqFilter]> eq_filters; 
    // [
    //     {filter_type: EQFilterType.lowpass, frequency: 1000.0, gain: 0.0, q: 0.0, enabled: true, selected: false, curve: "M 0 200 L 400 0 L 800 0"},
    //     {filter_type: EQFilterType.lowpass, frequency: 1000.0, gain: 0.0, q: 0.0, enabled: true, selected: false, curve: "M 0 200 L 400 400 L 800 0"}];
    in-out property <float> test;
    in-out property <int> selected_filter;
    in-out property <bool> huge_frequency;
    in-out property <string> selected_frequency;
    pure callback init_eq_filters();

    pure callback set_filter_frequency(int, float);
    pure callback set_filter_gain(int, float);
    pure callback set_filter_q(int, float);
    pure callback set_filter_enabled(int, bool);
    pure callback set_filter_selected(int, bool);
    pure callback set_filter_type(int, EQFilterType);     

    callback parse-frequency(int, float) -> float;
    parse-frequency(freq) => {
        if freq > 10000 {
            huge_frequency = true;
            round(freq / 100) / 10
        } else {
            round(freq/10) *10
        }
    }
    
    pure callback select_nearest_draggable(length, length);
    pure callback calculate_filter_coefficients(int);

    callback mx_to_gain(float) -> float;
    mx_to_gain(y_g) => {
        EQManagerSettings.max_gain  * (EQManagerSettings.eq_graph_height/2px - y_g) / (EQManagerSettings.eq_graph_height/2px);
    }
    callback gain_to_mx(float) -> float;
    gain_to_mx(float) => {
        EQManagerSettings.eq_graph_height/2px - (EQManagerSettings.eq_graph_height/2px * (float / EQManagerSettings.max_gain));
    }
    
    pure callback lin_to_f_skew(float) -> float;
    lin_to_f_skew(x) => {
        EQManagerSettings.min_freq 
        + (EQManagerSettings.max_freq - EQManagerSettings.min_freq) 
        * pow( x / (EQManagerSettings.eq_graph_width/1px), 1.0 / EQManagerSettings.skew_factor)   
    }

    pure callback f_to_lin_skew(float) -> float;
    f_to_lin_skew(y) => {
        (EQManagerSettings.eq_graph_width/1px - 1) 
        * pow((y - EQManagerSettings.min_freq) / (EQManagerSettings.max_freq - EQManagerSettings.min_freq), 
            EQManagerSettings.skew_factor)
    }
}



export component FilterTypeSelectorPopUp inherits PopupWindow {
    close-on-click: false;
    in-out property <int> id;
    Rectangle {
        background: #b7bed2;
        width: parent.width;
        height: parent.height;
        
        VerticalLayout {
            for filter_type in EQManagerSettings.list-of-filter-types:
                Rectangle {
                    width: parent.width;
                    height: 40px;
                    background: touch-area.has-hover? #e1d2b0 : #b7bed2;    
                    touch-area := TouchArea {
                        clicked => {
                            EQManagerUI.eq_filters[id].filter_type = filter_type;
                            EQManagerUI.set_filter_type(id, filter_type);
                            root.close();
                        }
                    }
                    
                    // Render-Text for Filter Selection
                    Text {

                        vertical-alignment: center;
                        horizontal-alignment: center;   

                        font-family: EQDesign.main-font;
                        font-size: EQDesign.font-main-size;

                        width: parent.width;
                        height: parent.height;
                        text: filter_type.str;

                    }
                } 
        }
    }
}

export component FilterTypeSelector {
    in-out property <int> id;
    in-out property <bool> popup;
    Rectangle {
        background: #0f3ec0;
        width: 100px;
        height: 40px;
    }
    touch-area:= TouchArea {
        clicked => {
            popup.show();
        }
    }
    
    HorizontalLayout {

        // Render-Text for selected FilterType
        Text {
            horizontal-alignment: center;
            vertical-alignment: center;

            font-family: EQDesign.main-font;
            font-size: EQDesign.font-main-size;

            text: EQManagerUI.eq_filters[id].filter_type.str;
            width: 100px;
            height: 40px;
        }    
    }

    // pop-up mechanism
    popup := FilterTypeSelectorPopUp {
        id: id;
        close-on-click: true;
        x: parent.x + parent.width;
        y: parent.y - parent.height * 5;
        width:  parent.width;
        height: parent.height * 7;
    }

}

    


export component FrequencyController {
    
    in-out property <string> frequency;
    in-out property <bool> huge_frequency: EQManagerUI.eq_filters[id].huge_frequency;// huge_frequency;
    in-out property <int> id;
    width: 120px;
    height: 40px;

    Rectangle {
        background: #b7bed2;    
    }

    HorizontalLayout {

        // Render-Text for frequency edit
        text-input := TextInput {
            
            width: parent.width;
            height: 40px;            
            vertical-alignment: center;
            horizontal-alignment: right;
            
            font-family: EQDesign.main-font;
            font-size: EQDesign.font-main-size;

            text: frequency;

            touch-area := TouchArea {
                clicked => { 
                    text-input.focus();

                }
            }
            
            accepted => {
                // EQManagerUI.eq_filters[id].frequency = text-input.text.to-float();
                EQManagerUI.eq_filters[id].parsed_frequency = EQManagerUI.parse-frequency(id, text-input.text.to-float());
                EQManagerUI.set_filter_frequency(id, text-input.text.to-float());
                EQManagerUI.calculate_filter_coefficients(id);
                self.clear-focus();
            }
        }

        // Render-Text frequency unit
        // Text {
        //     vertical-alignment: center;
        //     horizontal-alignment: center;
            
        //     font-family: EQDesign.main-font;
        //     font-size: EQDesign.font-main-size;

        //     text: huge_frequency ? "kHz" : "Hz";
        //     width: 40px;
        //     height: 40px;   
        // }
    }
    
}
export component GainController {
    
    in-out property <float> gain;
    in-out property <int> id;
    width: 200px;
    height: 40px;

    Rectangle {
        background: #b7bed2;    
    }
    HorizontalLayout {
        text-input := TextInput {
            vertical-alignment: center;
            horizontal-alignment: right;

            font-family: EQDesign.main-font;
            font-size: EQDesign.font-main-size;
            text: round(gain*10) / 10;
            width: 40px;
            height: 40px;
            touch-area := TouchArea {
                clicked => { 
                    text-input.focus();
                }
            }
            accepted => {
                EQManagerUI.eq_filters[id].gain;
                EQManagerUI.set_filter_gain(id, text-input.text.to-float());
                EQManagerUI.calculate_filter_coefficients(id);
                self.clear-focus();
            }
        }

        Text {
            vertical-alignment: center;
            horizontal-alignment: center;

            font-family: EQDesign.main-font;
            font-size: EQDesign.font-main-size;

            text: "dB";
            width: 40px;
            height: 40px;
        }
    }
    
}

export component QController {
        
        in-out property <float> q;
        in-out property <int> id;
        width:  80px;
        height: 40px;
    
        Rectangle {
            background: #b7bed2;    
        }
        HorizontalLayout {
           
            text-input := TextInput {
                vertical-alignment: center;
                horizontal-alignment: left;
                text: "Q: " + round(q * 100) / 100;
                font-family: EQDesign.main-font;
                font-size: EQDesign.font-main-size;
                width: parent.width;
                height: parent.height;
                touch-area := TouchArea {
                    clicked => { 
                        text-input.focus();
                    }
                }
                accepted => {
                    EQManagerUI.eq_filters[id].q;
                    EQManagerUI.set_filter_q(id, text-input.text.to-float());
                    EQManagerUI.calculate_filter_coefficients(id);
                    self.clear-focus();
                }
            }
        }
}
    


export component FilterControlStrip {
    width: 400px;
    height: 40px;
    Rectangle {    background: #353c51;    }
    in-out property <int> id;
    HorizontalLayout {
        alignment: center;
        FilterTypeSelector {
            width: 100px;
            height: 40px;
            id: id;
        }

        FrequencyController {
            // frequency: EQManagerUI.eq_filters[id].frequency; //EQManagerUI.eq_filters[id].frequency;
            huge_frequency: EQManagerUI.eq_filters[id].huge_frequency;
            id: id;
            width: 100px;
            height: 40px;

            states [
                f when self.huge_frequency: {
                    frequency: round(EQManagerUI.eq_filters[id].frequency / 100) / 10 + " kHz";
                } 
                ff when !self.huge_frequency: {
                    frequency: round(EQManagerUI.eq_filters[id].frequency / 10) * 10 + " Hz";
                }
            ]

        }
        GainController {
            gain: EQManagerUI.eq_filters[id].gain;
            id: id;
            width: 100px;
            height: 40px;
        }
        QController {
            q: EQManagerUI.eq_filters[id].q;
            id: id;
            width: 80px;
            height: 40px;
        }
    }
    visible: true;
}


export component EQCanvas {
    
    width:  800px;
    height: 800px;
    
    Rectangle {
        background: #b792ae;
    }

    touch-area := TouchArea {
        height: parent.height;
        width:  parent.width;
        property <length> pressed-value-x: self.pressed-x;
        property <length> pressed-value-y: self.pressed-y;
        
        pointer-event(event) => {

            // if event.button == PointerEventButton.left && event.kind == PointerEventKind.down {
            if event.kind == PointerEventKind.down {
                EQManagerUI.select_nearest_draggable(touch-area.mouse-x, touch-area.mouse-y)
            } 
        }
            
        // clicked => {

        // }

        moved => {
        
            if EQManagerUI.selected_filter != -1 {                
                EQManagerUI.eq_filters[EQManagerUI.selected_filter].circle_x = clamp((pressed-value-x + (touch-area.mouse-x - touch-area.pressed-value-x)), 0, parent.width );
                EQManagerUI.eq_filters[EQManagerUI.selected_filter].circle_y = clamp((pressed-value-y + (touch-area.mouse-y - touch-area.pressed-value-y)), 0, parent.height);            
                EQManagerUI.set_filter_frequency(
                    EQManagerUI.selected_filter, 
                    // EQManagerUI.eq_filters[EQManagerUI.selected_filter].circle_x / 1px
                    EQManagerUI.lin_to_f_skew(EQManagerUI.eq_filters[EQManagerUI.selected_filter].circle_x / 1px)
                );
                EQManagerUI.set_filter_gain(
                    EQManagerUI.selected_filter, 
                    EQManagerUI.mx_to_gain(EQManagerUI.eq_filters[EQManagerUI.selected_filter].circle_y / 1px)
                );        
                EQManagerUI.calculate_filter_coefficients(EQManagerUI.selected_filter);
            }            
        }

        in-out property <float> q_old: 0;
        in-out property <float> q_inc;

        scroll-event(per) => {
            
            q_inc = (((per.delta-y) / 60) /10) / 1px;
            q_old =  EQManagerUI.eq_filters[EQManagerUI.selected_filter].q + q_inc;
            // q_old = q_old + q_inc;
            // EQManagerUI.eq_filters[EQManagerUI.selected_filter].q += q_inc;
            EQManagerUI.set_filter_q(EQManagerUI.selected_filter, q_old);
            EQManagerUI.calculate_filter_coefficients(EQManagerUI.selected_filter);
            accept;
        }
    }
    
    for filter in EQManagerUI.eq_filters:  
        // Curve
        Path {
            viewbox-x: 0;
            viewbox-y: -200;
            viewbox-width: 800;
            viewbox-height: 400;
            stroke: black;
            stroke-width: 1px;
            commands: filter.curve;
        }

    // Draw interactive filter control point 
    for filter in EQManagerUI.eq_filters:
        // Circle width radius 15
        Rectangle {
            x: filter.circle_x - 15px;
            y: filter.circle_y - 15px;
            width: 30px;
            height: self.width;
            Rectangle {
                width: parent.width;
                height: self.width;
                border-radius: self.width/2;
                background: #914f4f;
            }
            
        }
    
    // Path {
    //     stroke: black;
    //     stroke-width: 2px;
    //     commands: "M 0 0 L 100 0 L 700 0 L 800 -200";
    //     viewbox-x: 0;
    //     viewbox-y: -200;
    //     viewbox-height: 400;
    //     viewbox-width: 800;
    // }
}   



export component TestWindow inherits Window {
    width: 800px;
    height: 800px;  
    background: #353c51;
    title: "TheEQfromBelow";
    VerticalLayout {
        spacing: 10px;


        Text {width: 800px; height: 50px; text : EQManagerUI.selected_filter;}
        eq-canvas := EQCanvas {
            width: EQManagerSettings.eq_graph_width;//  800px;
            height: EQManagerSettings.eq_graph_height;//;
        }
        
        HorizontalLayout {
            alignment: center;
            VerticalLayout {   
                 
                for id in [0,1,2,3]:
                    Rectangle {   
                        FilterControlStrip { id: id;
                            width: 400px;}      
                    }
            }
            VerticalLayout {
                alignment: center;
                for id in [4,5,6,7]:
                Rectangle {   
                    FilterControlStrip { id: id;
                        width: 400px;}      
                }
            }
            }
        }

     

}
//     visible: true;
// }