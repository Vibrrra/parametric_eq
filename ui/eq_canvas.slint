import { Button, HorizontalBox, VerticalBox } from "std-widgets.slint";

export global EQDesign {
    // Curve color schemes
    out property <color> eq_curve_color: red;
    out property <color> eq_curve_fill: red;
    out property <float> eq_curve_opacity: 0.2;
    out property <float> highlighted: 0.05;
    out property <string> main-font: "CodeNewRoman Nerd Font";
    out property <length> font-main-size: 17px;
    //  EQ Control Point color schemes
    out property <color> eq_control_point_color: grey;
    out property <color> eq_control_point_fill: grey;
    out property <float> eq_control_point_opacity: 0.15;

    // EQ Canvas background color
    out property <color> eq_canvas_background: lightgrey;
}

export component Circle inherits Path{
    in property <float> radius: 2;
    in property <float> cx;
    in property <float> cy;
    fill: EQDesign.eq_control_point_fill;
    stroke: black;
    MoveTo {x: cx; y: cy;}
    ArcTo {radius-x: radius; radius-y: radius; x: cx+2*radius; y: cy; x-rotation: 0; large-arc: true; sweep: true;}
    ArcTo {radius-x: radius; radius-y: radius; x:  cx; y: cy; x-rotation: 0; large-arc: true; sweep: true;}
}

export struct EQControlPointData {
    selected: bool,
    freq: float,
    gain: float,
    q_value: float,
    filter_id: int,
    x: length,
    y: length,
}



export component MySlider inherits Rectangle {
    in-out property<float> maximum: 100;
    in-out property<float> minimum: 0;
    in-out property<float> value;

    min-height: 24px;
    min-width: 100px;
    horizontal-stretch: 1;
    vertical-stretch: 0;

    border-radius: root.height/2;
    background: touch.pressed ? #eee: #ddd;
    border-width: 1px;
    border-color: root.background.darker(25%);

    handle := Rectangle {
        width: self.height;
        height: parent.height;
        border-width: 3px;
        border-radius: self.height / 2;
        background: touch.pressed ? #f8f: touch.has-hover ? #66f : #0000ff;
        border-color: self.background.darker(15%);
        x: (root.width - handle.width) * (root.value - root.minimum) / (root.maximum - root.minimum);
    }
    touch := TouchArea {
        property <float> pressed-value;
        pointer-event(event) => {
            if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                self.pressed-value = root.value;
            }
        }
        moved => {
            if (self.enabled && self.pressed) {
                root.value = max(root.minimum, min(root.maximum,
                    self.pressed-value 
                    + (touch.mouse-x - touch.pressed-x) 
                    * (root.maximum - root.minimum) 
                    / (root.width - handle.width)));
            }
        }
    }
}

export component Recipe inherits Window {
    VerticalBox {
        alignment: start;
        slider := MySlider {
            maximum: 100;
        }
        Text {
            text: "Value: \{round(slider.value)}";
        }
    }
}

export enum FilterType {
    LowPass, LowShelf, HighPass, HighShelf, BandPass, Notch, PeakingEQ
}

export struct DraggablePosition {
    x: float,
    y: float,
    id: int,
    selected: bool,
    active: bool,
    dist: float,
    hovered: bool,
    ta_x: length,
    ta_y: length,

    q_value: float,
    gain: float,
    filter_type: {str: string, type: FilterType},
}

export global DraggableLogic {
    pure callback get_nearest_filter([DraggablePosition]) -> int;
    callback calc_distance(float,float,float,float) -> float;
    calc_distance(x,y,mouse_x, mouse_y) => {
        sqrt( pow(x - mouse_x, 2) + pow(y - mouse_y, 2));
    }
    callback reset_draggable(int);
    reset_draggable(id) => {
        EQGraphManager.draggable_positions[id].ta_x = 0px;
        EQGraphManager.draggable_positions[id].ta_y = 0px;
    }
    callback push_ta_away(int);
    push_ta_away(id) => {
        EQGraphManager.draggable_positions[id].hovered = false;
    }
}

export struct EQCurveData {
    svg: string,
    highlighted: bool,
}

export global EQGraphManager {

    in-out property <length> eq_graph_width: 800px;
    in-out property <length> eq_graph_height: 250px;

    in-out property <int> n_freq_points: 250;
    in-out property <float> max_freq: 20000.0;
    in-out property <float> min_freq: 16.0;
    in-out property <float> max_gain: 30.0;
    in-out property <float> min_gain: -30.0;
    in-out property <float> max_q: 10.0;
    in-out property <float> min_q: 0.01;

    in-out property <float> skew_factor: 0.3;
    in-out property <bool> has-hover;
    in property <float> db_scaling_factor: (eq_graph_height  / 1px) / max_gain ;

    out property<[{str: string, type: FilterType}]> list-of-filter-types: 
        [{str: "LowPass"  , type: FilterType.LowPass,  }, 
         {str: "HighPass" , type: FilterType.HighPass, },
         {str: "BandPass" , type: FilterType.BandPass, },
         {str: "PeakingEQ", type: FilterType.PeakingEQ,}, 
         {str: "LowShelf" , type: FilterType.LowShelf, },
         {str: "HighShelf", type: FilterType.HighShelf,}
    ];    

    // init draggable positions
    in-out property <[DraggablePosition]> draggable_positions: [
        {x: 20 ,y: 20,  id: 0, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[1], q_value: 1.0},
        {x: 50 ,y: 120, id: 1, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[3], q_value: 1.0},
        {x: 70 ,y: 70,  id: 2, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[3], q_value: 1.0},
        {x: 100 ,y: 70,  id: 3, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[3], q_value: 1.0},
        {x: 132 ,y: 70,  id: 4, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[3], q_value: 1.0},
        {x: 160 ,y: 70,  id: 5, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[3], q_value: 1.0},
        {x: 200 ,y: 70,  id: 6, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[3], q_value: 1.0},
        {x: 220 ,y: 70,  id: 7, active: true, selected: false, hovered: has-hover, filter_type: list-of-filter-types[0], q_value: 1.0},
    ];

    in-out property <[EQCurveData]> eq_curve_data: [
        {svg: "", highlighted: false},
        {svg: "", highlighted: false},
        {svg: "", highlighted: false},
        {svg: "", highlighted: false},
        {svg: "", highlighted: false},
        {svg: "", highlighted: false},
        {svg: "", highlighted: false},
        {svg: "", highlighted: false}
    ];

    in-out property <string> eq_sum_curve;
    pure callback update_eq_sum_curves();

    in-out property  <string> new_curve;
    callback set_eq_curve(int, string);
    set_eq_curve(id, svg) => {
        eq_curve_data[id].svg = svg;
    }
    
    // pure callback highlight_filter(float, float) -> int;
    callback map_mouse_coords(float, float, length, length) ;
    callback set_selected(string);
    
    // 10.0f32.powf((x - x0) * (y1.log10() - y0.log10()) / (x1 - x0) + y0.log10())
    pure callback mx_to_f(float) -> float;
    mx_to_f(mx) => {
         pow( 10.0, ((mx - 0) * (log(max_freq,10) - log(min_freq,10)) / (eq_graph_width /1px - 0) + log(min_freq,10)) )  
    }     
    
    //   (y.log10() - y0.log10()) * (x1 - x0) / (y1.log10() - y0.log10()) + x0
    callback f_to_mx(float) -> float;
    f_to_mx(f) => {
        (log(f,10.0) - log(min_freq,10.0)) * (eq_graph_width /1px - 0) / (log(max_freq,10.0) - log(min_freq, 10)) + 0
    }

    pure callback lin_to_f_skew(float) -> float;
    lin_to_f_skew(x) => {
        min_freq + (max_freq - min_freq) * pow(x / (eq_graph_width/1px - 1), 1.0 / skew_factor)   
    }


    pure callback f_to_lin_skew(float) -> float;
    f_to_lin_skew(y) => {
        (eq_graph_width/1px - 1) * pow((y - min_freq) / (max_freq - min_freq), skew_factor)
    }

    callback selected_draggable(int, int);
    selected_draggable(id, id2) => {
        if id == id2 {
            draggable_positions[id].selected = true;   
            eq_curve_data[id].highlighted = true;   
            
        } else {
            draggable_positions[id].selected = false;
            eq_curve_data[id].highlighted = false;
            
        }
    }

   

    callback mx_to_gain(float) -> float;
    mx_to_gain(y_g) => {
        (EQGraphManager.eq_graph_height/2px - y_g) * (2 * EQGraphManager.db_scaling_factor);
    }
}

export component EQCurve {
    Rectangle { background: yellow; opacity: 0.1;}
    in property <EQCurveData> data;
    in-out property <int> filter_id;
    eq_curve_path := Path {
        // viewbox-x: 0;
        // viewbox-y: 0;
        // viewbox-height: 100;
        // viewbox-width: (EQGraphManager.eq_graph_width / 1px) / 2;
        commands: data.svg;
        stroke: EQDesign.eq_curve_color;
        fill: EQDesign.eq_curve_fill;
        // opacity: (filter_id == EQGraphManager.highlighted) ? EQDesign.eq_curve_opacity : EQDesign.highlighted;
        // opacity: eq_curve_data.highlighted ? EQDesign.highlighted : EQDesign.eq_curve_opacity;
    }

}




export component Draggable inherits Rectangle {
  
    

        
    callback reset_x_y();
    callback push_ta_away();

    // position variables
    x: self.center_x * 1px - self.width  / 2 ;
    y: self.center_y * 1px - self.height / 2;
    in-out property <float> center_x;
    in-out property <float> center_y;
    
    // meta data
    in-out property <int> id;
    in-out property <bool> active;
    in-out property <bool> selected;    
    in-out property <float> distance;
    in-out property <bool> hovered;
    
    
    // Look and feel
    background: active ? (selected ? red : blue) : grey;
    opacity: active ? 1.0 : (hovered ? 0.5 : 0.2);
    width: 10px;
    height: 10px;
    border-radius: self.width / 2;
    border-width: 2px;

    callback calc_distance(float,float) -> float;
    calc_distance(mxc,myc) => {
        distance = sqrt( pow(self.center_x - mxc, 2) + pow(self.center_y - myc, 2));
        distance
    }
}

component TESTPATH inherits Path{
    width: 500px;
    height: 250px;
        viewbox-x: 0;
        viewbox-y: 0;
        viewbox-height: 100;
        viewbox-width: (self.width / 1px) / 2;
        commands: "M 0 50 L 125 0  L 250 110 ";
        stroke: black;
       
}
     



export global EQCanvasLogic{
    pure callback get_nearest_filter([float]) -> int;
    // pure callback calc_new_filter(int, float, float, float, FilterType, float) -> string;
    callback calc_new_filter(DraggablePosition) ;//-> string;
}
    // pure function get_nearest_filter2(draggables: [DraggablePosition],mx: float,my: float) -> int 
export component EQCanvas inherits Rectangle {
    // width: parent.width;
    // height: parent.height;
    // min-width: 600px;
    // min-height: 500px;
    width: EQGraphManager.eq_graph_width;
    height: EQGraphManager.eq_graph_height;
    in-out property <[EQCurveData]> curve_data;


    in-out property <[EQControlPointData]> control_point_data: [{x: 0px,y: 10px,   },{x: 100px,y: 10px},{x: 300px,y: 300px},{}];
       
    property <EQControlPointData> active_control_point;
    in-out property <int> selected_draggable: -1;
    in-out property <EventResult> scroll_result;
    in-out property <length> scroll_x;
    in-out property <length> scroll_y: 0;  
    

    // look and feel
    
    VerticalLayout {

        Rectangle {    
            width: parent.width;
            height: parent.height;
            background: #c1f3ff;
                
            in property <length> drag1_x: ta.mouse-x;
            in property <length> drag1_y: ta.mouse-x;
        
            ta := TouchArea {
                width: 100%;//parent.width;
                height: 100%;//parent.height;
                property <length> pressed-value-x;
                property <length> pressed-value-y;
                
                in-out property <bool> moveds;
                pointer-event(event) => {

                    if (event.kind == PointerEventKind.move) {
                        selected_draggable = DraggableLogic.get_nearest_filter(EQGraphManager.draggable_positions);
                        EQGraphManager.selected_draggable(selected_draggable, selected_draggable);
                        moveds = true;
                    } else {
                        moveds = false;
                    }

                    // Check Mouse input left click
                    if (event.button == PointerEventButton.left && event.kind == PointerEventKind.down) {
                    
                        // EQ0
                        EQGraphManager.draggable_positions[0].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[0].x, 
                            EQGraphManager.draggable_positions[0].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ1
                        EQGraphManager.draggable_positions[1].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[1].x, 
                            EQGraphManager.draggable_positions[1].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ2        
                        EQGraphManager.draggable_positions[2].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[2].x, 
                            EQGraphManager.draggable_positions[2].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ3        
                        EQGraphManager.draggable_positions[3].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[3].x, 
                            EQGraphManager.draggable_positions[3].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ4        
                        EQGraphManager.draggable_positions[4].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[4].x, 
                            EQGraphManager.draggable_positions[4].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ5        
                        EQGraphManager.draggable_positions[5].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[5].x, 
                            EQGraphManager.draggable_positions[5].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ6        
                        EQGraphManager.draggable_positions[6].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[6].x, 
                            EQGraphManager.draggable_positions[6].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        // EQ7        
                        EQGraphManager.draggable_positions[7].dist = DraggableLogic.calc_distance(
                            EQGraphManager.draggable_positions[7].x, 
                            EQGraphManager.draggable_positions[7].y, 
                            ta.mouse-x / 1px, 
                            ta.mouse-y / 1px);
                        
                        // Get the nearest filter 
                        selected_draggable = DraggableLogic.get_nearest_filter(EQGraphManager.draggable_positions);
                        
                        pressed-value-x = EQGraphManager.draggable_positions[selected_draggable].x * 1px;
                        pressed-value-y = EQGraphManager.draggable_positions[selected_draggable].y * 1px;   
                        
                        // Set other filters as unselected
                        EQGraphManager.selected_draggable(0, selected_draggable);
                        EQGraphManager.selected_draggable(1, selected_draggable);
                        EQGraphManager.selected_draggable(2, selected_draggable);
                        EQGraphManager.selected_draggable(3, selected_draggable);
                        EQGraphManager.selected_draggable(4, selected_draggable);
                        EQGraphManager.selected_draggable(5, selected_draggable);
                        EQGraphManager.selected_draggable(6, selected_draggable);
                        EQGraphManager.selected_draggable(7, selected_draggable);

                        

                    } else if event.kind == PointerEventKind.up {
                    }
                }
            
                moved => {
                    if (self.enabled && self.pressed) {
                        
                        if selected_draggable == -1 {
                            return;
                        }
                        EQGraphManager.draggable_positions[selected_draggable].x = clamp((pressed-value-x + (ta.mouse-x - ta.pressed-value-x)) / 1px, 0, parent.width / 1px);
                        EQGraphManager.draggable_positions[selected_draggable].y = clamp((pressed-value-y + (ta.mouse-y - ta.pressed-value-y)) / 1px, 0, parent.height / 1px);
                        EQCanvasLogic.calc_new_filter(EQGraphManager.draggable_positions[selected_draggable]);
                        EQGraphManager.draggable_positions[selected_draggable].gain =  30 * (125  - EQGraphManager.draggable_positions[selected_draggable].y) /125 ;
                        EQGraphManager.set_eq_curve(selected_draggable, EQGraphManager.new_curve); 
                    }                 
                }
                
                in-out property <length> scroll_old;
                in-out property <float> q_inc;

                scroll-event(per) => {
                    
                
                    scroll_old =  per.delta-y; 
                    q_inc = ((scroll_old / 60) /10) / 1px;
                    
                    if selected_draggable == -1 {
                        return EventResult.reject;
                    }

                    EQGraphManager.draggable_positions[selected_draggable].q_value += q_inc;
                    EQGraphManager.draggable_positions[selected_draggable].q_value = clamp(EQGraphManager.draggable_positions[selected_draggable].q_value, EQGraphManager.min_q, EQGraphManager.max_q);
                    EQCanvasLogic.calc_new_filter(EQGraphManager.draggable_positions[selected_draggable]);
                    EQGraphManager.set_eq_curve(selected_draggable, EQGraphManager.new_curve);
                    
                    EventResult.accept   ;
                }

            
                double-clicked => {
                    
                    if selected_draggable == -1 {return;}
                    EQGraphManager.draggable_positions[selected_draggable].active = !EQGraphManager.draggable_positions[selected_draggable].active;
                    EQCanvasLogic.calc_new_filter(EQGraphManager.draggable_positions[selected_draggable]);

                }

                
                
            }
            Path {
                width: 100%;
                height: 100%; 
                viewbox-x: 0;
                viewbox-y: 0;
                viewbox-height: EQGraphManager.eq_graph_height/2px;
                viewbox-width: EQGraphManager.eq_graph_width/2px;
                clip: true;
                commands: EQGraphManager.eq_sum_curve;
                stroke: black;
                stroke-width: 1.5px;
                fill: #8884c3;
            }
            for eq_curve in EQGraphManager.eq_curve_data: 
                Path {  
                    width: 100%;
                    height: 100%;                    
                    viewbox-height: EQGraphManager.eq_graph_height/2px;
                    viewbox-width: EQGraphManager.eq_graph_width/2px;
                    viewbox-x: 0;
                    viewbox-y: 0;
                    clip: true;
                    commands: eq_curve.svg;
                    fill: eq_curve.highlighted?  #c38484 : transparent;
                    opacity: eq_curve.highlighted? 0.2 : 0.2;
                    stroke: eq_curve.highlighted? black : #3c3030 ;
                    stroke-width: eq_curve.highlighted? 1.5px : 1px;
                }
        
            for dp in EQGraphManager.draggable_positions: 
                Draggable {
                    clip: true;
                    center_x: dp.x;
                    center_y: dp.y;
                    active: dp.active;
                    id: dp.id;
                    selected: dp.selected;
                    hovered: dp.hovered;
                  
            }
            
            if false: 
                Path {
                    width: 100%;
                    height: 100%;
                    viewbox-height: EQGraphManager.eq_graph_height/2px;
                    viewbox-width: EQGraphManager.eq_graph_width/2px;
                    commands: "M -1 100.5 L \{ EQGraphManager.eq_graph_width/2 /1px +1} 0";
                    stroke: black;
                    stroke-width: 1.5px;
                }

            Text {
                // text: "MY: \{EQGraphManager.draggable_positions[selected_draggable].gain}";
                text: ta.moveds? "Moved" : "Not Moved";
            }      
        }
    }
}
